/* tslint:disable */
/* eslint-disable */
/**
 * BoardBot API
 * BoardBot API
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base"

/**
 *
 * @export
 * @interface ApplyDecisionRequestDto
 */
export interface ApplyDecisionRequestDto {
  /**
   *
   * @type {ApplyModerationDecision}
   * @memberof ApplyDecisionRequestDto
   */
  moderation?: ApplyModerationDecision
  /**
   *
   * @type {ApplyDuplicatePostsDecision}
   * @memberof ApplyDecisionRequestDto
   */
  duplicatePosts?: ApplyDuplicatePostsDecision
  /**
   *
   * @type {ApplyTagAssignmentDecision}
   * @memberof ApplyDecisionRequestDto
   */
  tagAssignment?: ApplyTagAssignmentDecision
}
/**
 *
 * @export
 * @interface ApplyDuplicatePostsDecision
 */
export interface ApplyDuplicatePostsDecision {
  /**
   *
   * @type {string}
   * @memberof ApplyDuplicatePostsDecision
   */
  duplicatePostExternalId?: string
}
/**
 *
 * @export
 * @interface ApplyModerationDecision
 */
export interface ApplyModerationDecision {
  /**
   *
   * @type {string}
   * @memberof ApplyModerationDecision
   */
  reason?: ApplyModerationDecisionReasonEnum
}

export const ApplyModerationDecisionReasonEnum = {
  MultipleSuggestions: "multiple_suggestions",
  IsAQuestion: "is_a_question",
  IsSpamOrInappropriate: "is_spam_or_inappropriate",
  IsAdvertisement: "is_advertisement",
  IsBugReport: "is_bug_report",
  IsNotUnderstandable: "is_not_understandable",
} as const

export type ApplyModerationDecisionReasonEnum =
  (typeof ApplyModerationDecisionReasonEnum)[keyof typeof ApplyModerationDecisionReasonEnum]

/**
 *
 * @export
 * @interface ApplyTagAssignmentDecision
 */
export interface ApplyTagAssignmentDecision {
  /**
   *
   * @type {Array<string>}
   * @memberof ApplyTagAssignmentDecision
   */
  tagIds?: Array<string>
}
/**
 *
 * @export
 * @interface BoardContextGetDto
 */
export interface BoardContextGetDto {
  /**
   *
   * @type {string}
   * @memberof BoardContextGetDto
   */
  productDescription: string
  /**
   *
   * @type {string}
   * @memberof BoardContextGetDto
   */
  productGoals: string
}
/**
 *
 * @export
 * @interface BoardContextPutRequestDto
 */
export interface BoardContextPutRequestDto {
  /**
   *
   * @type {string}
   * @memberof BoardContextPutRequestDto
   */
  productDescription?: string
  /**
   *
   * @type {string}
   * @memberof BoardContextPutRequestDto
   */
  productGoals?: string
}
/**
 *
 * @export
 * @interface BoardCreateRequestDto
 */
export interface BoardCreateRequestDto {
  /**
   * The name of the board
   * @type {string}
   * @memberof BoardCreateRequestDto
   */
  name: string
}
/**
 *
 * @export
 * @interface BoardGet
 */
export interface BoardGet {
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  vendor: BoardGetVendorEnum | null
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof BoardGet
   */
  updatedAt: string
}

export const BoardGetVendorEnum = {
  Fider: "fider",
} as const

export type BoardGetVendorEnum =
  (typeof BoardGetVendorEnum)[keyof typeof BoardGetVendorEnum]

/**
 *
 * @export
 * @interface BoardGetOneResponse
 */
export interface BoardGetOneResponse {
  /**
   *
   * @type {BoardGet}
   * @memberof BoardGetOneResponse
   */
  data: BoardGet
}
/**
 *
 * @export
 * @interface BoardPutRequestDto
 */
export interface BoardPutRequestDto {
  /**
   *
   * @type {string}
   * @memberof BoardPutRequestDto
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof BoardPutRequestDto
   */
  description: string
}
/**
 *
 * @export
 * @interface BoardsGetResponse
 */
export interface BoardsGetResponse {
  /**
   *
   * @type {Array<BoardGet>}
   * @memberof BoardsGetResponse
   */
  data: Array<BoardGet>
}
/**
 *
 * @export
 * @interface DuplicatePost
 */
export interface DuplicatePost {
  /**
   * The ID of the duplicate post
   * @type {string}
   * @memberof DuplicatePost
   */
  id: string
  /**
   * The reasoning of the duplicate post
   * @type {string}
   * @memberof DuplicatePost
   */
  reasoning?: string
}
/**
 *
 * @export
 * @interface DuplicatePostsDecision
 */
export interface DuplicatePostsDecision {
  /**
   * The status of the duplicate posts decision
   * @type {DuplicatePostsDecisionStatusEnum}
   * @memberof DuplicatePostsDecision
   */
  status: DuplicatePostsDecisionStatusEnum
  /**
   * The decision of the duplicate posts
   * @type {DuplicatePostsDecisionEnum}
   * @memberof DuplicatePostsDecision
   */
  decision: DuplicatePostsDecisionEnum
  /**
   * List of duplicate posts with their reasoning
   * @type {Array<DuplicatePost>}
   * @memberof DuplicatePostsDecision
   */
  duplicatePosts: Array<DuplicatePost>
  /**
   * The AI reasoning
   * @type {string}
   * @memberof DuplicatePostsDecision
   */
  reasoning?: string
}

/**
 * The decision of the duplicate posts
 * @export
 * @enum {string}
 */

export const DuplicatePostsDecisionEnum = {
  Duplicate: "duplicate",
  NotDuplicate: "not_duplicate",
  Unknown: "unknown",
} as const

export type DuplicatePostsDecisionEnum =
  (typeof DuplicatePostsDecisionEnum)[keyof typeof DuplicatePostsDecisionEnum]

/**
 * The status of the duplicate posts decision
 * @export
 * @enum {string}
 */

export const DuplicatePostsDecisionStatusEnum = {
  Success: "success",
  Failed: "failed",
} as const

export type DuplicatePostsDecisionStatusEnum =
  (typeof DuplicatePostsDecisionStatusEnum)[keyof typeof DuplicatePostsDecisionStatusEnum]

/**
 *
 * @export
 * @interface FiderBoardCreateDto
 */
export interface FiderBoardCreateDto {
  /**
   *
   * @type {string}
   * @memberof FiderBoardCreateDto
   */
  baseUrl: string
  /**
   *
   * @type {string}
   * @memberof FiderBoardCreateDto
   */
  apiKey: string
}
/**
 *
 * @export
 * @interface HealthControllerCheck200Response
 */
export interface HealthControllerCheck200Response {
  /**
   *
   * @type {string}
   * @memberof HealthControllerCheck200Response
   */
  status?: string
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck200Response
   */
  info?: { [key: string]: HealthControllerCheck200ResponseInfoValue } | null
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck200Response
   */
  error?: { [key: string]: HealthControllerCheck200ResponseInfoValue } | null
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck200Response
   */
  details?: { [key: string]: HealthControllerCheck200ResponseInfoValue }
}
/**
 *
 * @export
 * @interface HealthControllerCheck200ResponseInfoValue
 */
export interface HealthControllerCheck200ResponseInfoValue {
  [key: string]: any

  /**
   *
   * @type {string}
   * @memberof HealthControllerCheck200ResponseInfoValue
   */
  status: string
}
/**
 *
 * @export
 * @interface HealthControllerCheck503Response
 */
export interface HealthControllerCheck503Response {
  /**
   *
   * @type {string}
   * @memberof HealthControllerCheck503Response
   */
  status?: string
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck503Response
   */
  info?: { [key: string]: HealthControllerCheck200ResponseInfoValue } | null
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck503Response
   */
  error?: { [key: string]: HealthControllerCheck200ResponseInfoValue } | null
  /**
   *
   * @type {{ [key: string]: HealthControllerCheck200ResponseInfoValue; }}
   * @memberof HealthControllerCheck503Response
   */
  details?: { [key: string]: HealthControllerCheck200ResponseInfoValue }
}
/**
 *
 * @export
 * @interface IncludesGetDto
 */
export interface IncludesGetDto {
  /**
   * The related posts
   * @type {Array<PostGet>}
   * @memberof IncludesGetDto
   */
  posts: Array<PostGet>
}
/**
 *
 * @export
 * @interface ModerationDecision
 */
export interface ModerationDecision {
  /**
   * The decision of the moderation
   * @type {ModerationDecisionEnum}
   * @memberof ModerationDecision
   */
  decision: ModerationDecisionEnum
  /**
   * The reason of the moderation
   * @type {ModerationReasonEnum}
   * @memberof ModerationDecision
   */
  reason?: ModerationReasonEnum
  /**
   * The AI reasoning
   * @type {string}
   * @memberof ModerationDecision
   */
  reasoning?: string
}

/**
 * The decision of the moderation
 * @export
 * @enum {string}
 */

export const ModerationDecisionEnum = {
  Accepted: "accepted",
  Rejected: "rejected",
  Unknown: "unknown",
} as const

export type ModerationDecisionEnum =
  (typeof ModerationDecisionEnum)[keyof typeof ModerationDecisionEnum]

/**
 * The reason of the moderation
 * @export
 * @enum {string}
 */

export const ModerationReasonEnum = {
  MultipleSuggestions: "multiple_suggestions",
  IsAQuestion: "is_a_question",
  IsSpamOrInappropriate: "is_spam_or_inappropriate",
  IsAdvertisement: "is_advertisement",
  IsBugReport: "is_bug_report",
  IsNotUnderstandable: "is_not_understandable",
} as const

export type ModerationReasonEnum =
  (typeof ModerationReasonEnum)[keyof typeof ModerationReasonEnum]

/**
 *
 * @export
 * @interface PostDecision
 */
export interface PostDecision {
  /**
   *
   * @type {ModerationDecision}
   * @memberof PostDecision
   */
  moderation?: ModerationDecision
  /**
   *
   * @type {DuplicatePostsDecision}
   * @memberof PostDecision
   */
  duplicatePosts?: DuplicatePostsDecision
  /**
   *
   * @type {TagAssignmentDecision}
   * @memberof PostDecision
   */
  tagAssignment?: TagAssignmentDecision
}
/**
 *
 * @export
 * @interface PostGet
 */
export interface PostGet {
  /**
   *
   * @type {PostProcessingStatusEnum}
   * @memberof PostGet
   */
  processingStatus: PostProcessingStatusEnum
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  description: string
  /**
   *
   * @type {PostDecision}
   * @memberof PostGet
   */
  decision?: PostDecision
  /**
   *
   * @type {BoardGet}
   * @memberof PostGet
   */
  board: BoardGet
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  postCreatedAt: string
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  externalId: string
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof PostGet
   */
  updatedAt: string
}

/**
 *
 * @export
 * @interface PostGetResponse
 */
export interface PostGetResponse {
  /**
   *
   * @type {PostGet}
   * @memberof PostGetResponse
   */
  data: PostGet
  /**
   *
   * @type {IncludesGetDto}
   * @memberof PostGetResponse
   */
  includes: IncludesGetDto
}
/**
 * Filter posts by processing statuses
 * @export
 * @enum {string}
 */

export const PostProcessingStatusEnum = {
  Pending: "pending",
  AwaitingManualReview: "awaiting_manual_review",
  Completed: "completed",
  Failed: "failed",
} as const

export type PostProcessingStatusEnum =
  (typeof PostProcessingStatusEnum)[keyof typeof PostProcessingStatusEnum]

/**
 *
 * @export
 * @interface PostsGetResponse
 */
export interface PostsGetResponse {
  /**
   *
   * @type {Array<PostGet>}
   * @memberof PostsGetResponse
   */
  data: Array<PostGet>
  /**
   *
   * @type {string}
   * @memberof PostsGetResponse
   */
  nextCursor: string | null
}
/**
 *
 * @export
 * @interface PostsSearchRequestDto
 */
export interface PostsSearchRequestDto {
  /**
   * Filter posts by processing statuses
   * @type {Array<PostProcessingStatusEnum>}
   * @memberof PostsSearchRequestDto
   */
  statuses?: Array<PostProcessingStatusEnum>
  /**
   * Cursor for pagination (typically the ID of the last post from previous page)
   * @type {string}
   * @memberof PostsSearchRequestDto
   */
  cursor?: string
  /**
   * Maximum number of posts to return
   * @type {number}
   * @memberof PostsSearchRequestDto
   */
  limit?: number
  /**
   * Filter posts by board IDs
   * @type {Array<string>}
   * @memberof PostsSearchRequestDto
   */
  boardIds?: Array<string>
}
/**
 *
 * @export
 * @interface TagAssignmentDecision
 */
export interface TagAssignmentDecision {
  /**
   * The status of the tag assignment
   * @type {TagAssignmentDecisionStatusEnum}
   * @memberof TagAssignmentDecision
   */
  status: TagAssignmentDecisionStatusEnum
  /**
   * The tag IDs
   * @type {Array<string>}
   * @memberof TagAssignmentDecision
   */
  tagIds: Array<string>
  /**
   * The AI reasoning
   * @type {string}
   * @memberof TagAssignmentDecision
   */
  reasoning?: string
}

/**
 * The status of the tag assignment
 * @export
 * @enum {string}
 */

export const TagAssignmentDecisionStatusEnum = {
  Success: "success",
  Failed: "failed",
} as const

export type TagAssignmentDecisionStatusEnum =
  (typeof TagAssignmentDecisionStatusEnum)[keyof typeof TagAssignmentDecisionStatusEnum]

/**
 *
 * @export
 * @interface TagGenerateDescriptionResponseDto
 */
export interface TagGenerateDescriptionResponseDto {
  /**
   *
   * @type {string}
   * @memberof TagGenerateDescriptionResponseDto
   */
  description: string
}
/**
 *
 * @export
 * @interface TagGet
 */
export interface TagGet {
  /**
   *
   * @type {string}
   * @memberof TagGet
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof TagGet
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof TagGet
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof TagGet
   */
  externalId: string
}
/**
 *
 * @export
 * @interface TagPut
 */
export interface TagPut {
  /**
   *
   * @type {string}
   * @memberof TagPut
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof TagPut
   */
  description: string
}
/**
 *
 * @export
 * @interface TagsGetResponse
 */
export interface TagsGetResponse {
  /**
   *
   * @type {Array<TagGet>}
   * @memberof TagsGetResponse
   */
  data: Array<TagGet>
}
/**
 *
 * @export
 * @interface TagsPutRequestDto
 */
export interface TagsPutRequestDto {
  /**
   *
   * @type {Array<TagPut>}
   * @memberof TagsPutRequestDto
   */
  tags: Array<TagPut>
}

/**
 * BoardContextApi - axios parameter creator
 * @export
 */
export const BoardContextApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get board context
     * @param {string} boardId Board ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardContextControllerGetBoardContext: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists(
        "boardContextControllerGetBoardContext",
        "boardId",
        boardId,
      )
      const localVarPath = `/boards/{boardId}/context`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update board context
     * @param {string} boardId Board ID
     * @param {BoardContextPutRequestDto} boardContextPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardContextControllerUpdateBoardContext: async (
      boardId: string,
      boardContextPutRequestDto: BoardContextPutRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists(
        "boardContextControllerUpdateBoardContext",
        "boardId",
        boardId,
      )
      // verify required parameter 'boardContextPutRequestDto' is not null or undefined
      assertParamExists(
        "boardContextControllerUpdateBoardContext",
        "boardContextPutRequestDto",
        boardContextPutRequestDto,
      )
      const localVarPath = `/boards/{boardId}/context`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        boardContextPutRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BoardContextApi - functional programming interface
 * @export
 */
export const BoardContextApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BoardContextApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get board context
     * @param {string} boardId Board ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardContextControllerGetBoardContext(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BoardContextGetDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardContextControllerGetBoardContext(
          boardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "BoardContextApi.boardContextControllerGetBoardContext"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update board context
     * @param {string} boardId Board ID
     * @param {BoardContextPutRequestDto} boardContextPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardContextControllerUpdateBoardContext(
      boardId: string,
      boardContextPutRequestDto: BoardContextPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardContextControllerUpdateBoardContext(
          boardId,
          boardContextPutRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "BoardContextApi.boardContextControllerUpdateBoardContext"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * BoardContextApi - factory interface
 * @export
 */
export const BoardContextApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BoardContextApiFp(configuration)
  return {
    /**
     *
     * @summary Get board context
     * @param {string} boardId Board ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardContextControllerGetBoardContext(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BoardContextGetDto> {
      return localVarFp
        .boardContextControllerGetBoardContext(boardId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update board context
     * @param {string} boardId Board ID
     * @param {BoardContextPutRequestDto} boardContextPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardContextControllerUpdateBoardContext(
      boardId: string,
      boardContextPutRequestDto: BoardContextPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .boardContextControllerUpdateBoardContext(
          boardId,
          boardContextPutRequestDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BoardContextApi - object-oriented interface
 * @export
 * @class BoardContextApi
 * @extends {BaseAPI}
 */
export class BoardContextApi extends BaseAPI {
  /**
   *
   * @summary Get board context
   * @param {string} boardId Board ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardContextApi
   */
  public boardContextControllerGetBoardContext(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardContextApiFp(this.configuration)
      .boardContextControllerGetBoardContext(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update board context
   * @param {string} boardId Board ID
   * @param {BoardContextPutRequestDto} boardContextPutRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardContextApi
   */
  public boardContextControllerUpdateBoardContext(
    boardId: string,
    boardContextPutRequestDto: BoardContextPutRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardContextApiFp(this.configuration)
      .boardContextControllerUpdateBoardContext(
        boardId,
        boardContextPutRequestDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * BoardsApi - axios parameter creator
 * @export
 */
export const BoardsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a new board
     * @param {BoardCreateRequestDto} boardCreateRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerCreateBoard: async (
      boardCreateRequestDto: BoardCreateRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardCreateRequestDto' is not null or undefined
      assertParamExists(
        "boardControllerCreateBoard",
        "boardCreateRequestDto",
        boardCreateRequestDto,
      )
      const localVarPath = `/boards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        boardCreateRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a board by ID
     * @param {string} boardId The ID of the board to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerDeleteBoard: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("boardControllerDeleteBoard", "boardId", boardId)
      const localVarPath = `/boards/{boardId}`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a board by ID
     * @param {string} boardId The ID of the board to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerGetBoard: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("boardControllerGetBoard", "boardId", boardId)
      const localVarPath = `/boards/{boardId}`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all boards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerGetBoards: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/boards`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Sync a board by ID
     * @param {string} boardId The ID of the board to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerSyncBoard: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("boardControllerSyncBoard", "boardId", boardId)
      const localVarPath = `/boards/{boardId}/sync`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a board by ID
     * @param {string} boardId The ID of the board to update
     * @param {BoardPutRequestDto} boardPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerUpdateBoard: async (
      boardId: string,
      boardPutRequestDto: BoardPutRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("boardControllerUpdateBoard", "boardId", boardId)
      // verify required parameter 'boardPutRequestDto' is not null or undefined
      assertParamExists(
        "boardControllerUpdateBoard",
        "boardPutRequestDto",
        boardPutRequestDto,
      )
      const localVarPath = `/boards/{boardId}`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        boardPutRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BoardsApi - functional programming interface
 * @export
 */
export const BoardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BoardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Create a new board
     * @param {BoardCreateRequestDto} boardCreateRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerCreateBoard(
      boardCreateRequestDto: BoardCreateRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BoardGetOneResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerCreateBoard(
          boardCreateRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerCreateBoard"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Delete a board by ID
     * @param {string} boardId The ID of the board to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerDeleteBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerDeleteBoard(
          boardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerDeleteBoard"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get a board by ID
     * @param {string} boardId The ID of the board to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerGetBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BoardGetOneResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerGetBoard(
          boardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerGetBoard"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get all boards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerGetBoards(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BoardsGetResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerGetBoards(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerGetBoards"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Sync a board by ID
     * @param {string} boardId The ID of the board to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerSyncBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerSyncBoard(
          boardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerSyncBoard"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update a board by ID
     * @param {string} boardId The ID of the board to update
     * @param {BoardPutRequestDto} boardPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async boardControllerUpdateBoard(
      boardId: string,
      boardPutRequestDto: BoardPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.boardControllerUpdateBoard(
          boardId,
          boardPutRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["BoardsApi.boardControllerUpdateBoard"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * BoardsApi - factory interface
 * @export
 */
export const BoardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BoardsApiFp(configuration)
  return {
    /**
     *
     * @summary Create a new board
     * @param {BoardCreateRequestDto} boardCreateRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerCreateBoard(
      boardCreateRequestDto: BoardCreateRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BoardGetOneResponse> {
      return localVarFp
        .boardControllerCreateBoard(boardCreateRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a board by ID
     * @param {string} boardId The ID of the board to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerDeleteBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .boardControllerDeleteBoard(boardId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a board by ID
     * @param {string} boardId The ID of the board to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerGetBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BoardGetOneResponse> {
      return localVarFp
        .boardControllerGetBoard(boardId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all boards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerGetBoards(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BoardsGetResponse> {
      return localVarFp
        .boardControllerGetBoards(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Sync a board by ID
     * @param {string} boardId The ID of the board to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerSyncBoard(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .boardControllerSyncBoard(boardId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a board by ID
     * @param {string} boardId The ID of the board to update
     * @param {BoardPutRequestDto} boardPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    boardControllerUpdateBoard(
      boardId: string,
      boardPutRequestDto: BoardPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .boardControllerUpdateBoard(boardId, boardPutRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BoardsApi - object-oriented interface
 * @export
 * @class BoardsApi
 * @extends {BaseAPI}
 */
export class BoardsApi extends BaseAPI {
  /**
   *
   * @summary Create a new board
   * @param {BoardCreateRequestDto} boardCreateRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerCreateBoard(
    boardCreateRequestDto: BoardCreateRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardsApiFp(this.configuration)
      .boardControllerCreateBoard(boardCreateRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a board by ID
   * @param {string} boardId The ID of the board to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerDeleteBoard(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardsApiFp(this.configuration)
      .boardControllerDeleteBoard(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a board by ID
   * @param {string} boardId The ID of the board to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerGetBoard(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardsApiFp(this.configuration)
      .boardControllerGetBoard(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all boards
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerGetBoards(options?: RawAxiosRequestConfig) {
    return BoardsApiFp(this.configuration)
      .boardControllerGetBoards(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Sync a board by ID
   * @param {string} boardId The ID of the board to sync
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerSyncBoard(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardsApiFp(this.configuration)
      .boardControllerSyncBoard(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a board by ID
   * @param {string} boardId The ID of the board to update
   * @param {BoardPutRequestDto} boardPutRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BoardsApi
   */
  public boardControllerUpdateBoard(
    boardId: string,
    boardPutRequestDto: BoardPutRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return BoardsApiFp(this.configuration)
      .boardControllerUpdateBoard(boardId, boardPutRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FiderBoardsApi - axios parameter creator
 * @export
 */
export const FiderBoardsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create or update a Fider board
     * @param {string} boardId The ID of the board to set
     * @param {FiderBoardCreateDto} fiderBoardCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fiderBoardControllerCreateOrUpdate: async (
      boardId: string,
      fiderBoardCreateDto: FiderBoardCreateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists(
        "fiderBoardControllerCreateOrUpdate",
        "boardId",
        boardId,
      )
      // verify required parameter 'fiderBoardCreateDto' is not null or undefined
      assertParamExists(
        "fiderBoardControllerCreateOrUpdate",
        "fiderBoardCreateDto",
        fiderBoardCreateDto,
      )
      const localVarPath = `/boards/{boardId}/fider-board`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        fiderBoardCreateDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a Fider board by board ID
     * @param {string} boardId The ID of the board to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fiderBoardControllerGetByBoardId: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("fiderBoardControllerGetByBoardId", "boardId", boardId)
      const localVarPath = `/boards/{boardId}/fider-board`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FiderBoardsApi - functional programming interface
 * @export
 */
export const FiderBoardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FiderBoardsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Create or update a Fider board
     * @param {string} boardId The ID of the board to set
     * @param {FiderBoardCreateDto} fiderBoardCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fiderBoardControllerCreateOrUpdate(
      boardId: string,
      fiderBoardCreateDto: FiderBoardCreateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fiderBoardControllerCreateOrUpdate(
          boardId,
          fiderBoardCreateDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          "FiderBoardsApi.fiderBoardControllerCreateOrUpdate"
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get a Fider board by board ID
     * @param {string} boardId The ID of the board to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fiderBoardControllerGetByBoardId(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fiderBoardControllerGetByBoardId(
          boardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["FiderBoardsApi.fiderBoardControllerGetByBoardId"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FiderBoardsApi - factory interface
 * @export
 */
export const FiderBoardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FiderBoardsApiFp(configuration)
  return {
    /**
     *
     * @summary Create or update a Fider board
     * @param {string} boardId The ID of the board to set
     * @param {FiderBoardCreateDto} fiderBoardCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fiderBoardControllerCreateOrUpdate(
      boardId: string,
      fiderBoardCreateDto: FiderBoardCreateDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .fiderBoardControllerCreateOrUpdate(
          boardId,
          fiderBoardCreateDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a Fider board by board ID
     * @param {string} boardId The ID of the board to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fiderBoardControllerGetByBoardId(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .fiderBoardControllerGetByBoardId(boardId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FiderBoardsApi - object-oriented interface
 * @export
 * @class FiderBoardsApi
 * @extends {BaseAPI}
 */
export class FiderBoardsApi extends BaseAPI {
  /**
   *
   * @summary Create or update a Fider board
   * @param {string} boardId The ID of the board to set
   * @param {FiderBoardCreateDto} fiderBoardCreateDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FiderBoardsApi
   */
  public fiderBoardControllerCreateOrUpdate(
    boardId: string,
    fiderBoardCreateDto: FiderBoardCreateDto,
    options?: RawAxiosRequestConfig,
  ) {
    return FiderBoardsApiFp(this.configuration)
      .fiderBoardControllerCreateOrUpdate(boardId, fiderBoardCreateDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a Fider board by board ID
   * @param {string} boardId The ID of the board to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FiderBoardsApi
   */
  public fiderBoardControllerGetByBoardId(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return FiderBoardsApiFp(this.configuration)
      .fiderBoardControllerGetByBoardId(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthControllerCheck: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthControllerCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HealthControllerCheck200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.healthControllerCheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.healthControllerCheck"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthControllerCheck(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<HealthControllerCheck200Response> {
      return localVarFp
        .healthControllerCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public healthControllerCheck(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .healthControllerCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Apply a decision to a post
     * @param {string} postId The ID of the post to apply the decision to
     * @param {ApplyDecisionRequestDto} applyDecisionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerApplyDecision: async (
      postId: string,
      applyDecisionRequestDto: ApplyDecisionRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postId' is not null or undefined
      assertParamExists("postControllerApplyDecision", "postId", postId)
      // verify required parameter 'applyDecisionRequestDto' is not null or undefined
      assertParamExists(
        "postControllerApplyDecision",
        "applyDecisionRequestDto",
        applyDecisionRequestDto,
      )
      const localVarPath = `/posts/{postId}/apply-decision`.replace(
        `{${"postId"}}`,
        encodeURIComponent(String(postId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        applyDecisionRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a post by ID
     * @param {string} postId The ID of the post to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerGetPost: async (
      postId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postId' is not null or undefined
      assertParamExists("postControllerGetPost", "postId", postId)
      const localVarPath = `/posts/{postId}`.replace(
        `{${"postId"}}`,
        encodeURIComponent(String(postId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search for posts across all boards with cursor pagination
     * @param {PostsSearchRequestDto} postsSearchRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerSearchPosts: async (
      postsSearchRequestDto: PostsSearchRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postsSearchRequestDto' is not null or undefined
      assertParamExists(
        "postControllerSearchPosts",
        "postsSearchRequestDto",
        postsSearchRequestDto,
      )
      const localVarPath = `/posts/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        postsSearchRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Sync a post by ID
     * @param {string} postId The ID of the post to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerSyncPost: async (
      postId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'postId' is not null or undefined
      assertParamExists("postControllerSyncPost", "postId", postId)
      const localVarPath = `/posts/{postId}/sync`.replace(
        `{${"postId"}}`,
        encodeURIComponent(String(postId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Apply a decision to a post
     * @param {string} postId The ID of the post to apply the decision to
     * @param {ApplyDecisionRequestDto} applyDecisionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postControllerApplyDecision(
      postId: string,
      applyDecisionRequestDto: ApplyDecisionRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postControllerApplyDecision(
          postId,
          applyDecisionRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PostsApi.postControllerApplyDecision"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get a post by ID
     * @param {string} postId The ID of the post to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postControllerGetPost(
      postId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostGetResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postControllerGetPost(postId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PostsApi.postControllerGetPost"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Search for posts across all boards with cursor pagination
     * @param {PostsSearchRequestDto} postsSearchRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postControllerSearchPosts(
      postsSearchRequestDto: PostsSearchRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PostsGetResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postControllerSearchPosts(
          postsSearchRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PostsApi.postControllerSearchPosts"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Sync a post by ID
     * @param {string} postId The ID of the post to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postControllerSyncPost(
      postId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postControllerSyncPost(postId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["PostsApi.postControllerSyncPost"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PostsApiFp(configuration)
  return {
    /**
     *
     * @summary Apply a decision to a post
     * @param {string} postId The ID of the post to apply the decision to
     * @param {ApplyDecisionRequestDto} applyDecisionRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerApplyDecision(
      postId: string,
      applyDecisionRequestDto: ApplyDecisionRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .postControllerApplyDecision(postId, applyDecisionRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a post by ID
     * @param {string} postId The ID of the post to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerGetPost(
      postId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PostGetResponse> {
      return localVarFp
        .postControllerGetPost(postId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search for posts across all boards with cursor pagination
     * @param {PostsSearchRequestDto} postsSearchRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerSearchPosts(
      postsSearchRequestDto: PostsSearchRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PostsGetResponse> {
      return localVarFp
        .postControllerSearchPosts(postsSearchRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Sync a post by ID
     * @param {string} postId The ID of the post to sync
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postControllerSyncPost(
      postId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .postControllerSyncPost(postId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
  /**
   *
   * @summary Apply a decision to a post
   * @param {string} postId The ID of the post to apply the decision to
   * @param {ApplyDecisionRequestDto} applyDecisionRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postControllerApplyDecision(
    postId: string,
    applyDecisionRequestDto: ApplyDecisionRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return PostsApiFp(this.configuration)
      .postControllerApplyDecision(postId, applyDecisionRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a post by ID
   * @param {string} postId The ID of the post to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postControllerGetPost(
    postId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PostsApiFp(this.configuration)
      .postControllerGetPost(postId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search for posts across all boards with cursor pagination
   * @param {PostsSearchRequestDto} postsSearchRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postControllerSearchPosts(
    postsSearchRequestDto: PostsSearchRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return PostsApiFp(this.configuration)
      .postControllerSearchPosts(postsSearchRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Sync a post by ID
   * @param {string} postId The ID of the post to sync
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostsApi
   */
  public postControllerSyncPost(
    postId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PostsApiFp(this.configuration)
      .postControllerSyncPost(postId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queueControllerAdd: async (
      body: object,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("queueControllerAdd", "body", body)
      const localVarPath = `/queue/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QueueApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queueControllerAdd(
      body: object,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queueControllerAdd(body, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["QueueApi.queueControllerAdd"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = QueueApiFp(configuration)
  return {
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queueControllerAdd(
      body: object,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .queueControllerAdd(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueApi
   */
  public queueControllerAdd(body: object, options?: RawAxiosRequestConfig) {
    return QueueApiFp(this.configuration)
      .queueControllerAdd(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerGenerateDescription: async (
      tagId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tagId' is not null or undefined
      assertParamExists("tagControllerGenerateDescription", "tagId", tagId)
      const localVarPath = `/tags/{tagId}/generate-description`.replace(
        `{${"tagId"}}`,
        encodeURIComponent(String(tagId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerGetTags: async (
      boardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("tagControllerGetTags", "boardId", boardId)
      const localVarPath = `/boards/{boardId}/tags`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} boardId
     * @param {TagsPutRequestDto} tagsPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerPutTags: async (
      boardId: string,
      tagsPutRequestDto: TagsPutRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'boardId' is not null or undefined
      assertParamExists("tagControllerPutTags", "boardId", boardId)
      // verify required parameter 'tagsPutRequestDto' is not null or undefined
      assertParamExists(
        "tagControllerPutTags",
        "tagsPutRequestDto",
        tagsPutRequestDto,
      )
      const localVarPath = `/boards/{boardId}/tags`.replace(
        `{${"boardId"}}`,
        encodeURIComponent(String(boardId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        tagsPutRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagControllerGenerateDescription(
      tagId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TagGenerateDescriptionResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tagControllerGenerateDescription(
          tagId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["TagsApi.tagControllerGenerateDescription"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagControllerGetTags(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TagsGetResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tagControllerGetTags(boardId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["TagsApi.tagControllerGetTags"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} boardId
     * @param {TagsPutRequestDto} tagsPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagControllerPutTags(
      boardId: string,
      tagsPutRequestDto: TagsPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.tagControllerPutTags(
          boardId,
          tagsPutRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap["TagsApi.tagControllerPutTags"]?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TagsApiFp(configuration)
  return {
    /**
     *
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerGenerateDescription(
      tagId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TagGenerateDescriptionResponseDto> {
      return localVarFp
        .tagControllerGenerateDescription(tagId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} boardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerGetTags(
      boardId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TagsGetResponse> {
      return localVarFp
        .tagControllerGetTags(boardId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} boardId
     * @param {TagsPutRequestDto} tagsPutRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagControllerPutTags(
      boardId: string,
      tagsPutRequestDto: TagsPutRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .tagControllerPutTags(boardId, tagsPutRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
  /**
   *
   * @param {string} tagId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public tagControllerGenerateDescription(
    tagId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TagsApiFp(this.configuration)
      .tagControllerGenerateDescription(tagId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} boardId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public tagControllerGetTags(
    boardId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return TagsApiFp(this.configuration)
      .tagControllerGetTags(boardId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} boardId
   * @param {TagsPutRequestDto} tagsPutRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public tagControllerPutTags(
    boardId: string,
    tagsPutRequestDto: TagsPutRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return TagsApiFp(this.configuration)
      .tagControllerPutTags(boardId, tagsPutRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
